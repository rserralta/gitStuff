#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include<ctype.h>
#include"hash.h"
#define REPLACE 1
#define SWAP 2
#define ERASE 4

#define BINS 101
#define MAX_LEN 100
#define BUF_SIZE 60
// struct node {
//   struct node *next;
//   char *value;
// };
// typedef struct node node;
// typedef struct {
//   node **table;
//   int size;
//   int bins;
// } hashset;
//-------------------------------------

//char correction_list[1000][60];
//int indx = 0;
//hashset corrections=set_init();

// void add_list(char* correction) {
//     if (indx < 1000) {
//         strncpy(correction_list[indx], correction, 59);
//         correction_list[indx][59] = '\0';
//         indx++;
//     }
// }

// void print_list() {
//     for (int i = 0; i < indx; i++) {
//         printf("%s,\n", correction_list[i]);
//     }
// }

void cmd_r(char*word, hashset hash_set){
  
  for(int i=0;i<strlen(word);i++){
    for(char k = 'a'; k<='z'; k++){
      char og_char=word[i];
      word[i]=k;
      if(search(hash_set,word)){//if true
       // add_list(word);
        //insert(&corrections,word);
        printf("%s",word);
      }
      word[i]=og_char;
        
    }
  }
  //add_list("/");

}// end cmd_r-----------------------------------


void cmd_s(char *word, hashset hash_set) {
  size_t length = strlen(word);
  if (length < 2) return;  // If there's less than two characters, no swap can occur

  for (int i = 0; i < length - 1; i++) {  // Ensure i+1 does not go out of bounds
    char og_char = word[i];
    char og_char2 = word[i + 1];
    word[i] = og_char2;
    word[i + 1] = og_char;

    if (search(hash_set, word)) {  // Check if the swapped word exists in the hash set
      //add_list(word);
      //insert(&corrections,word);
      printf("%s",word);
    }

    // Swap back to restore original word
    word[i] = og_char;
    word[i + 1] = og_char2;
  }
  //add_list("/");
}

void cmd_e(char *word, hashset hash_set) {
  size_t length = strlen(word);  
  char *extracted = malloc(length + 1);  // Allocate enough space for the null terminator
  for (int i = 0; i < length; i++) {
    int e_index = 0;  // Index for 'extracted'
    for (int j = 0; j < length; j++) {
      if (i != j) {
        extracted[e_index++] = word[j];  // Populate 'extracted' skipping 'word[i]'
      }
    }
      extracted[e_index] = '\0';  // Null-terminate the string
      if (search(hash_set, extracted)) {  // If true
        //add_list(extracted);
       // insert(&corrections,extracted);
        printf("%s",extracted);
      }
  }
  //add_list("/");

  free(extracted);  // Free the memory allocated for 'extracted'
}// end cmd_e----------------------------------


int main(int argc, char**argv){// ./programName -d fileName
  // populating the hashset---->
  char* file_path;
  //if (strstr(argv[1],"-d")){
  if (strchar(argv[1],"-")&&strchar(argv[1],"d")){    
    file_path=argv[2];//error
  }else{
    file_path= "words.txt";
  }
  hashset set = set_init();
  
  FILE* words_file = fopen(file_path, "r" /* "w", or "a" */);
  char buffer[BUF_SIZE];
  while(fgets(buffer, BUF_SIZE, words_file)){
      int len = strlen(buffer);
      if(buffer[len-1] == '\n')
          buffer[len-1] = '\0';
      //printf("next line: %s\n", buffer);
      insert(&set, buffer);
  }
  fclose(words_file);

  int line;
  char row[MAX_LEN];
  while(fgets(row,MAX_LEN,stdin)){
    line++;
    int len2 = strlen(row);
    // if ( len2 >= 2 && row[len2 - 2] == '\n') {
    //   row[len2 - 2] = '\0'; // Remove the newline character
    // }else{ 
     
      int column = 1;
      char* r_stream = strtok(row,"\t\n");
      while (r_stream != NULL) {
        if (!search(set, r_stream)){
          column++;
         // char line_str[4];
          //char column_str[4];
          printf("\nr_stream: %s",r_stream);
          // add_list(r_stream);
          // insert(&corrections, r_stream);
          sprintf(line_str, "%d", line);//doesnt print in councel 
          // add_list(line_str);
          printf("\nline: %d",line);
          printf("\ncolumn: %d",column);
          //insert(&correstions,line_str);
          //sprintf(column_str, "%d", column);
          //add_list(column_str);
          //insert(&corrections, column_str);
          //if(strstr(argv[2],"-r")){
          if (strchar(argv[1],"-")&&strchar(argv[1],"r")){    
            cmd_r(r_stream,set);
          }
          //if(strstr(argv[2],"-s")){
          if (strchar(argv[1],"-")&&strchar(argv[1],"s")){   
            cmd_s(r_stream,set);
          }

          //if(strstr(argv[2],"-e")){
          if (strchar(argv[1],"-")&&strchar(argv[1],"e")){   
            cmd_e(r_stream,set);
          }
          

        }//if
        //corrections[indx]="\0";
        printf("%s\n","end")
        r_stream = strtok(NULL,"\t\n");
      }//while
    //}//else
        
      
      
    
 }//while
  //  for (int i = 0; i <= indx; i++) {
  //       printf("%s", correction_list[i]);
  //   }
  //print_all(corrections);

}//end main
